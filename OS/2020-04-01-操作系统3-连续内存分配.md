

# CPU内存
&emsp;&emsp; CPU-L1cache-L2cache-memery-disk
# 逻辑地址空间
&emsp;&emsp; 抽象、隔离、保护、共享、虚拟化(临时放入disk)
# 内存管理
&emsp;&emsp; 程序重定向，分段，分页，虚拟内存，按需分叶虚拟内存
# 地址空间和地址生成
&emsp;&emsp; C程序用变量表示地址，汇编还是用符号，机器码就开始使用逻辑地址了，CPU的MMU中有一段区域来映射逻辑地址到物理地址
# 约束程序的内存
&emsp;&emsp; 程序只可以访问他自己的内存，当他访问其他地方的时候，操作系统应该使用安全检测
# 内存碎片
&emsp;&emsp; 外部碎片，是分配单元之间的内存碎片
&emsp;&emsp; 内部碎片，已经分配给了应用程序，但是应用程序没法使用它
# 连续内存分配
&emsp;&emsp; 程序启动的时候要分配，运行的时候要分配
<!-- more -->
# 第一匹配分配算法
&emsp;&emsp; 一个一个找，第一个碰到的合法的就分出去，
&emsp;&emsp; 需要按地址排序，分配的时候需要寻找合适的分区，还有看自由分区能否与相邻空闲分区合并
&emsp;&emsp; 简单，容易产生更大的空闲块，
&emsp;&emsp;容易产生外碎片
# 最优分配算法
&emsp;&emsp; 找差值最小的分区，分过去
&emsp;&emsp; 按尺寸排序，分配需要查找，也要合并相邻空闲分区
&emsp;&emsp; 避免分割大空间块，当大部分分配的是小尺寸的时候非常有效，
&emsp;&emsp; 容易产生外部碎片，合并空闲分区慢，容易产生大量微小碎片
# 最差匹配分配
&emsp;&emsp; 找最大的分区分过去
&emsp;&emsp; 按尺寸排序，分配快，也要合并
&emsp;&emsp; 分配中等尺寸有效
&emsp;&emsp; 合并慢，外部碎片，破碎空间没有大空间了
# 压缩式碎片整理
&emsp;&emsp; 挪动已经分配过的空间，
&emsp;&emsp; 什么时候挪动？销量？
# 交换式碎片整理
&emsp;&emsp; 和硬盘交换，使用虚拟内存的方法。
&emsp;&emsp; 把哪个换出去？什么时候换？





