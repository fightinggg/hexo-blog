---
mathjax: true
---

# MD5算法和SHA1算法
&emsp;&emsp; 这是一个哈希函数，他很复杂，取了很多奇怪的数字，然后对数据分段，然后疯狂的加减和各种位运算，这导致了他不可逆

# CRC算法
&emsp;&emsp; 把数据看为一个二进制串，进而把每一位看作系数，于是成了一个多项式f(x)，让这个多项式乘以$x^k$,然后模上g(x),得到余数h(x), 我们传输的时候传输$F(x)=f(x)*x^k+h(x)$,验证的时候F(x)模g(x)为0即可

# 置换
&emsp;&emsp; 这个东西嘿嘿嘿，不是这篇博客的重点，了解一小下叫置换群：）
&emsp;&emsp; 只要知道置换是可逆的就行了

# AES算法
&emsp;&emsp; 把明文分组，每组128位即16字节
&emsp;&emsp; 先把一维的message做成一个二维的列优先矩阵[4\*4], 然后进行很多轮下述操作
- 字节置换， 把矩阵的每一个元素查表替换为另一个元素
- 行位移， 第一行不变，第二行向右移动一个单位，第三行移动两个，以此类推
- 列混淆，在模群下，让自己乘上一个矩阵A(确保A存在逆元)， 
- 轮密钥加，就是异或另一个矩阵B即可
&emsp;&emsp; 不难发现第四步可以再次异或B复原，第三步可以乘上A的逆复原，第二步可以向左移位复原，第一步可以查表复原，第

# DES算法
&emsp;&emsp; 把明文分组，每组64位即8字节
- 初始置换， 通过查表的方式，把每一位上的元素替换为另一个位上的元素
- 加密处理，共16轮，先把64位的数据拆为两个32位的数据L和R，$L_i=R_{i-1},R_i=L_{i-1}^f(R_{i-1],k_{n-1}})$ k是一个密钥
- 函数f 第一步，密钥置换 ， 用64位的密钥生成16个48位的子密钥，每一轮使用不同的子密钥，使用循环左移生成
- 函数f 第二步，拓展置换 ， 讲32位的R改变位的次序并重复某些位，拓展为48位，
- 函数f 第三步，S盒替换 ， 把48位的R分割为8个6位的小段，对每一个段使用S盒来替换，输出是4位，故而最终R又从48位变成了32位，
- 函数f 第四步，P盒置换 , 把32位的R再次和初始置换类似的方法置换即可
&emsp;&emsp; 解密一样的啦

# RSA算法
&emsp;&emsp; 基于大合数难以分解的原理，达到难以破解，基于模群的性质达到加密和解密

# ECC算法
&emsp;&emsp; 一个基于圆锥曲线的算法，非对称加密算法

