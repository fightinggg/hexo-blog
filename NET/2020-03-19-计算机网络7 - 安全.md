
# 安全
&emsp;&emsp; 加密，有两种，对称加密和非对称加密，先用非对称加密，然后用对称加密
&emsp;&emsp; 加密 = 正确的发送者和完整性

# RSA加密
&emsp;&emsp; 两个大素数p,q相乘得到N，显然$$\phi(N)=\phi(p)*\phi(q)=(p-1)*(q-1)$$,找到两个数e,d满足$$ed\%\phi(N)=1$$,这里可以先随便生成一个e，然后利用exgcd算出d，显然e需要与$$\phi(N)$$互质，否则无解。
&emsp;&emsp; 其中(e,N)为公钥，(d,N)为私钥。
&emsp;&emsp; 证明$x^{ed}\%N=x$,如果x与N互质，显然成立，如果x与N不互质，不是一般性，假设$x=kp$， 则$$x^{ed}\%q=x\%q$$, 于是$$x^{ed}=x+tq$$,这一步很细节，都知道$$=x\%q+tq$$成立，为什么这样也成立？则$$x^{ed}\%p=(x+tq)\%p=tq\%p=0$$，即tq同时是p和q的倍数，于是$$x^{ed}\%N=(x+tq)\%N=x$$

<!---more-->
# 数字签名
&emsp;&emsp; 和信息一起发送，让别人知道这条信息是自己发的，因为公钥解密后是签名

## 加速签名
&emsp;&emsp; RSA性能不佳，只对摘要签名，摘要是校验和加认证加上时间戳，要不然别人拿着老消息断章取义

# 无线网安全
&emsp;&emsp; 防监听，防蹭网


## WPA2

# WEB安全
&emsp;&emsp; 监听c/s流量，篡改c/s消息，假冒web服务器

## SSL/TLS
&emsp;&emsp;~~浏览器通知服务器自己支持的加密协议，服务器选择协议并告诉浏览器证书，浏览器用CA的公钥鉴别证书，浏览器用公钥加密一个随机数发给服务器，服务器解密后把随机数和加密后的新的对称密钥返回给浏览器，双方开始对称加密。~~
&emsp;&emsp; 客户端请求SSL连接，发送一个随机数和客户端支持的加密算法，
&emsp;&emsp; 服务端回复加密算法，一个随机数，CA证书和签名，公钥
&emsp;&emsp; 客户端验证CA证书和签名，再生成一个随机数，并用公钥加密，返回给服务端
&emsp;&emsp; 服务端用私钥解密随机数，现在他应该知道3个随机数，用他们通过一定算法生产对称加密的密钥，然后尝试用这个给客户端发送一个消息来测试密钥

# DNS安全
&emsp;&emsp; DNS伪装,使用加密。


# 防火墙
&emsp;&emsp; 防火墙对每个包，作出决策，接受或丢弃
## 无状态防火墙
&emsp;&emsp; 拒绝某些服务、端口、目标
## 有状态防火墙
&emsp;&emsp; 允许内部主机连接后接受TCP包
## 应用层防火墙
&emsp;&emsp; 查看包内容，进行安全检测

# VPN
## 隧道
&emsp;&emsp; IP in IP，在IP外再次封装一层IP实现虚拟链路封包

# DoS
&emsp;&emsp; 畸形包、发送TCP连接请求但不发送接下来的，
## IP伪装
&emsp;&emsp; 将假的源地址放到包上，ISP要干一些事情来预防这种事件
