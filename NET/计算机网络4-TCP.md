---
title: 计算机网络4 - TCP
mathjax: true
categories:
  - 计算机网络
tags:
  - 计算机网络
keywords:
  - 计算机网络
abbrlink: 7eb080d1
date: 2020-03-19 15:44:54
---

# TCP
&emsp;&emsp; TCP传输是一种可靠传输的实现

# 不可靠传输的问题
- 包丢失
- 包损坏
- 包乱序
- 包延时
- 包重复

# 建立TCP连接
&emsp;&emsp; 为什么TCP连接需要建立呢? 为了确保网络的可达性。

## 如何建立连接，为什么是三次握手
&emsp;&emsp; 考虑这样一个场景，有个人叫C在河边散步，他记得河对面有个人叫S，但是河上雾太大了，他看不清对面。他想和对面的人对话。
<!---more-->
&emsp;&emsp; 既然是你想和对面的人说话，你首先得喊一声吧: "喂喂喂！河对面的S在吗？"，这时候可能有多种情况发生，见1，2，3，4
&emsp;&emsp; 1. 突然河面上跳出一条大鱼，把你的声音盖住了，S没有听到你的声音。于是对话结束了吗？不你得多试几次。再去喊他，要是每次都被这条该死的鱼给盖住了，那就意味着你的消息无法送达到河对面。对不起，网络连接可能有问题。
&emsp;&emsp; 2. 你的声音传了过去，但是被河中间的河神偷偷改变了，于是对面听到"喂喂喂！河对面的S死了吗？"，这时候S可能就不高兴了，他尽量分析你的句子的意思，这时候如果他分析出来你想说"喂喂喂！河对面的S在吗？"，那就好这等价于下面的情况4，若分析不出，他可能就当你是个傻子说骚话了，就不管你了。
&emsp;&emsp; 3. 你的声音传了过去，对面不在，哦豁，这时你可能会再叫他，叫的次数多了就知道叫不通了。
&emsp;&emsp; 4. 你的声音传了过去，对面听到了，作为一个礼貌的人，S要回答你的话。他对你说"我S在河对面！"，这时候又得看大鱼跳还是不跳了和河神干不干坏事了,如5，6，7,8
&emsp;&emsp; 5. 大鱼跳了，S一看自己说话了半天，你不回答他，S就要再次说"我S在河对面！"，这就又重复到情况4去了，要是S说了多次你还不回答他,S就不理你了，而你可能还会以为他没有听到你说的"喂喂喂！对面的S在吗？"在不断的尝试。
&emsp;&emsp; 6. 河神干坏事了，结果你听到了"我lbw真的没有开挂！"，你就得发挥你机智的头脑，把这句话分析为"我S在河对面"。要是分析不出来，和情况5没啥区别，要是分析出来了就进入7,8
&emsp;&emsp; 7. 你的声音传了过去，对面听到了，给你说了"我S在河对面！"，你也听到了，很多人这就结束了，你是过瘾了，喊S说话，S理了你，但S呢，莫名其妙的有个人叫了自己，自己给他回了话，然后对面就不说话了，这是S可能就在担心，"哎！他听到我说我在河对面了吗？"，然后他为了验证自己的担心不是多余的，就一直继续说"我S在河对面！",时间长了S就会想，对面怕不会是个聋子吧。这个交流显然是失败的。
&emsp;&emsp; 8. 你的声音传了过去，对面听到了，给你说了"我S在河对面！"，你也听到了，这时候为了防止对面认为你是个聋子，你得再给他说一句，"很好很好，我知道你在河对面了"，这是有可能发生很多情况，就得看鱼和河神了。
&emsp;&emsp; 9.要是他俩又干坏事，S要么听不到你说话，认为你是个聋子，要么听见你说骚话，认为你是个傻子，这两种情况他都会不断地多次对你说，"我S在河对面"，要不就分析出你说"很好很好，我知道你在河对面了",认为你是个正常人。现在你们都认为对面是正常人了。谈话很愉快。

## 三次握手携带更多的信息
&emsp;&emsp; 通常我们在握手的时候，就告诉对面自己的初始包号，然后第二次和第三次握手的时候就能携带ACK数据了。

# 如何关闭连接，为什么是四次挥手
&emsp;&emsp; 原理一样的，我们忽略丢包和包损坏，不妨设C要准备去吃饭了，这时候S还在滔滔不绝的讲着他的故事，C对S说，"我要吃饭了"，S听到后说"好的，我听到你说你要去吃饭了，但是你先等我把这故事讲完再走"，这是C能离开吗？显然不能，他得等着，知道S说"我讲完了"，这时候已经挥手了三次了，你还不能走，你得根S说，"我听到你说讲完了"之后才能离开，为什么呢?因为你要是不说的话，对面可能以为你没听到他说的“我讲完了"，说一共是挥手4次。

# 滑动窗口超时问题
&emsp;&emsp; 多久没有收到ACK才代表着所有的包全部丢失？这个很难确定，我们可以让他自适应

## 自适应RTT
&emsp;&emsp;$$SRTT_n = 0.9*SRTT_{n-1} + 0.1*RTT_n$$ 这个代表RTT的期望
&emsp;&emsp;$$SVAR_n = 0.9*SVAR_{n-1} + 0.1*|RTT_n-SRTT_n|$$ 这个代表RTT的方差
&emsp;&emsp; 当一个包超过期望+3倍的方差仍未回应ACK，视为丢包

# 滑动窗口丢包问题
&emsp;&emsp; 3次ACK，则丢包

# 流控制
&emsp;&emsp; 我们一直在想办法加速我们的网络，用到了发送端滑动窗口，但是如果接收端的内存太小，受不起如此快的传输，就只能丢弃后面收到的包，尽管已经收到了，这时候我们常常让接收端告诉发送端自己还剩下多少缓存取，来放慢传输速率，高效利用网络。


# 拥塞控制
&emsp;&emsp; 由于网络上各个线路的带宽不同，可能导致拥堵，TCP协议是闭环，通过反馈信息来判断是否拥堵。
## AIMD
&emsp;&emsp; 没有阻塞的时候，滑动窗口大小+1，阻塞的时候除以2，

# ACK时钟启动
&emsp;&emsp; 发送端一次性发送大量的包，然后开始等待ACK，等到一个ACK就发下一个包，这样就能降低丢包和延时？？，刚开始会有网络的爆发，后面会平滑

# TCP慢启动
&emsp;&emsp; 使用指数的方式，先发一个包，然后每收到一个ACK，(滑动窗口增大1)发两个包，当拥塞的时候滑动窗口减半。

# 超时控制
&emsp;&emsp; 超时以后使用慢启动(AIMD),更好的检测丢包能保证更好的AIMD

# 快速重传快速恢复
&emsp;&emsp; 当3次ACK检测丢包后，认为丢包，重传一个段,然后积性减少滑动窗口
## 为什么是3次
&emsp;&emsp; 顺序重排也会导致多次ACK
## 为什么积性减少
&emsp;&emsp; 消除超时或丢失后的慢启动，因为重传了一个段，可能后面会收到大量的ACK，预先减少滑动窗口，防止拥塞

# ECN(Explicit Congestion Notification)
&emsp;&emsp; 显示拥塞通知,路由器通过队列检测拥塞，标记收影响的包，被标记的包送达时，接收端视为丢失，然后反馈给发送端拥塞消息。

