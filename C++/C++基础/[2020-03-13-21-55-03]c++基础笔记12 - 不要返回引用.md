---
mathjax: true
---

# 引用
&emsp;&emsp; 为了防止拷贝构造函数导致的额外开销，我们往往把函数的参数设为const &，我也曾一直想如果返回值也是const &,会不会更快
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int>& f(int n) { 
  vector<int> res(100,0);
  res[0]=n;
  return res;
}

int main() {
  vector<int> a = f(10);
  a[0] = 1;
}
```
<!---more-->
&emsp;&emsp; 显然是错误的做法。你怎么可以想返回一个局部变量。
&emsp;&emsp; 然后是一个看似正确的做法。我们返回一个static内部变量。
```cpp
#include <iostream>
#include <vector>
using namespace std;

vector<int>& f(int n) { 
  static vector<int> res(100,0);
  res[0]=n;
  return res;
}

int main() {
  vector<int> a = f(10);
  a[0] = 1;
}
```
&emsp;&emsp; 在大多数情况下这确实是正确的做法。然而下面这个操作，
```cpp
int main() { cout << (f(0) == f(1)); }
```
&emsp;&emsp; 我不想解释为什么输出是1
&emsp;&emsp; 反正就是尽量少用这种引用就行了，单例模式除外。不用你去想着怎么优化这里，编译器会帮我们做。
