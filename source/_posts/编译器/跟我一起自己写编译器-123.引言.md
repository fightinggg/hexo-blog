---
date: 2021-06-24 22:25:00
updated: 2021-08-29 17:41:00
tags: [跟我一起写编译器,读书]
typora-root-url: ..\..
---

# 1. 引言

想做编译器很久了，大学期间留下了不少遗憾，没有实现自己的编译器，没有实现自己的`JVM`，没有实现自己的数据库，当然这其中有很多原因，比如学院的要求太松，比如自己也不够主动，经过两个多月的学习，笔者的Pava1.0以及Pava编译器已经发布，这篇`Blog`主要介绍理论，将引导读者一步一步构建一个自己的[编译器](https://github.com/fightinggg/compiler)。

# 2. 学习重点

开发编译器我能学到什么？编译器本身吗？其实不对，我们设计编译器的时候，会遇到很多问题，解决这些问题的方法才是最终重要的东西。

# 3. 编译器的流程

从头开发一个编译器是非常困难的，这涉及到很多知识点，这一部分主要介绍现代编译器的架构。

龙书上把编译器分为前端和后端两个部分，源代码首先经过前端转化为中间代码，中间代码经过后端转化为汇编文件。此后的工作就不是编译器的管理范围了，接下来由汇编器和链接器将汇编文件转化为可执行文件。

```mermaid
graph LR
  源代码 --编译器前端--> 中间代码 --编译器后端--> 汇编文件 --汇编器和链接器--> 可执行文件
```

为什么编译器要分为两个部分？为什么要分出前端和后端？实际上这样的架构做好以后，只要我们为$m$种源代码编写一个前端，为$n$种架构的机器编写后端，则我们可以组成$n*m$种编译器。当一个新类型的源代码或者新架构的机器出现时，我们可以以更快的速度对编译器进行更新，从而支持这些源代码或机器。另一方面，如果想要对源程序进行优化，编译器前端负责优化吗？还是编译器后端负责优化？这其实是优化器的工作，优化器的输入是中间代码，输出也是中间代码。

<!-- more -->

接下来读者最关心的问题，应该是中间代码是什么样的？中间代码并不只是一种形式，如果我们忽略优化器，就可以认为中间代码就是一个固定的形式。这个形式就是三地址形式或四元组形式，至于三地址形式和四元式形式究竟是什么，我们后面再做介绍。



## 3.1. 编译器前端流程

从源代码到中间代码，编译器已经有了很成熟的架构，一般分为下面这几步。

```mermaid
graph LR
  源代码 --词法分析器--> token流 --语法分析器--> 语法树  --中间代码生成器--> 中间代码 
```

## 3.2. 编译器后端流程

```mermaid
graph LR
  语法树  --中间代码生成器--> 中间代码1 --机器无关优化--> 中间代码2 --机器有关优化--> 中间代码3 --汇编代码生成器--> 汇编代码
```

# 系列博客

[跟我一起写编译器](https://fightinggg.github.io/tags/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99%E7%BC%96%E8%AF%91%E5%99%A8/)









