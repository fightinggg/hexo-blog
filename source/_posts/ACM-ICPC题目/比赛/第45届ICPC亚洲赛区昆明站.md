---
date: 2021-04-21 00:54:00
updated: 2021-04-21 00:54:00
mathjax: true
---

# L Simone and graph coloring

## 链接

https://ac.nowcoder.com/acm/contest/12548/L?&headNav=acm

## 题意

给你一个排列，排列的长度不超过$10^6$。你要对他的每一个元素进行染色，要求染色后不存在任何一个逆序对的两个元素颜色相同。你需要输出染色的数组。





## 输入

```txt
2
4
1 3 4 2
2
1 2
```

## 输出

```txt
2
1 1 1 2 
1
1 1
```

<!-- more -->

## 题解

逆向思维，我们假设自己已经有了一个答案，我们对着这个答案按照颜色对排列进行子序列拆分，则有几个颜色就有一个子序列，这些子序列恰好构成原排列的一个划分。



可以断言，每一个子序列都是严格单调增。

然后回到正向思维，我们要做的就是把这个排列分成n个单调增的划分，如何最小化n？

我们贪心地维护一些桶，并按顺序枚举排列中的元素，把他们放到这些桶里面，保证桶中的数据单调增，如果他无法放入任何桶，则为他新建一个桶，如果他可以放入多个桶，则选择最后一个元素最大的那个桶。

## 代码

```c++
#include <iostream>
#include <vector>
#include <map>

using namespace std;

void solve(vector<int> a) {
    map<int, int> mp;
    vector<int> color(a.size());

    int cnt = 0;


    mp[a[0]] = 1;
    color[0] = ++cnt;

    for (int i = 1; i < a.size(); i++) {
        // *it >= key
        auto it = mp.lower_bound(a[i]);

        if (it == mp.begin()) {
            mp[a[i]] = ++cnt;
            color[i] = cnt;
        } else {
            --it;
            mp[a[i]] = it->second;
            color[i] = it->second;
            mp.erase(it);
        }
    }

    cout << cnt << "\n";
    for (int x:color) {
        cout << x << " ";
    }
    cout << "\n";
}


int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; i++) {
            cin >> a[i];
        }
        solve(a);
    }
}
```





# M Stone Games

## 链接

https://ac.nowcoder.com/acm/contest/12548/M

## 题意

给你一个长度1e6的数组，1e5组询问，每次询问这个数组的一个子串(subString)， 对于这个子串的所有子序列(subSequence)，他们各自的和构成的集合的mex为多少。强制在线。

补充： mex函数表示是：不在该集合中的最小的非负整数的值

## 输入

```txt
5 5
1 4 2 1 6
1 3
2 1
2 4
1 4
3 4
```

## 输出

```txt
8
15
4
9
4
```

## 说明

由于进行了强制在线处理，所有的输入进行了加密，下面是解密后的内容

> In the example above, the actual query intervals are` [2,4]`,`[1,5]`,`[3,5]`,`[1,4]` and `[3,4]`.



## 题解

### 暴力

考虑一个数列，他的所有子序列各自的和的mex要怎么计算，比如`1 4 2 1 6 20 21`

先排序`1 1 2 4 6 20 21`, 然后依次检验前缀和，

首先整数区间`[0,0]`都可行，只要一个数不选即可

然后考虑第一个数1，区间变为`[0,1]`

然后考虑第二个数1，区间变为`[0,2]`

然后考虑第三个数2，区间变为`[0,4]`

然后考虑第一个数4，区间变为`[0,8]`

然后考虑第一个数6，区间变为`[0,14]`

然后考虑第一个数20，前缀无法扩展了因为你无论如何都无法构造出数字15，于是最后一个数字21也不用考虑了。



### 区间加速

上面的办法太慢了，如果这个序列长度为n，则要计算n次。能不能加速这个过程？

考虑到如果枚举到第i个数的时候，区间为`[0,x]`, 则对于所有小于等于`x+1`的数，我们都可以合并到区间，一旦发现没有小于等于`x+1`的数的时候，算法可以结束了，这个序列无法构造数字`x+1`

由于每一轮枚举可以把很多数字加入到区间中，区间的右端点以指数的方式增加，所以这个算法只会枚举lg次。



### 主席树维护区间和

剩下的问题就是区间中小于等于x的数的和是多少了，这个是主席树模版题。









