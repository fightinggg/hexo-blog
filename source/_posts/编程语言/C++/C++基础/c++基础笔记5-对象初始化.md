---
date: 2020-03-13 16:57:30
updated: 2020-03-13 16:57:30
mathjax: true
---

# 对象在使用以前一定要初始化
 基本数据类型这里就不说了，直接讲类
 类的对象的初始化往往使用了构造函数，但是很多人不会写构造函数，他们这样实现
```cpp
#include <iostream>
using namespace std;

class node {
  int x;

 public:
  node() {}
  node(int x_) { x = x_; }
};

class my_class {
  node a, b, c, d;

 public:
  my_class(node a_, node b_, node c_, node d_) {
    a = a_;
    b = b_;
    c = c_;
    d = d_;
  }
};
int main() {}```

<!---more-->
 这样实现没有问题，但是效率较低，c++标准保证类的构造函数调用之前初始化先调用成员的构造函数。这样以来，my_class里面的abcd都被先初始化再赋值了，通常我们使用冒号来构造他们。
```cpp
#include <iostream>
using namespace std;

class node {
  int x;

 public:
  node() {}
  node(int x_) : x(x_) {}
};

class my_class {
  node a, b, c, d;

 public:
  my_class(node a_, node b_, node c_, node d_) : a(a_), b(b_), c(c_), d(d_) {}
};

int main() {}```
## 小细节
 c++标准规定了这里的构造顺序是与声明顺序为序的，而不是冒号后面的顺序。

# 不同编译单元的非局部静态变量顺序问题
 先看代码，这是一个.h
```cpp
#include <iostream>
using namespace std;

class my_class {};
extern my_class mls;
```
 注意到有一个extern my_class mls;如果我们有多个编译单元，每个都extern一些对象，这些对象初始化的顺序，c++没有规定，所以可能导致他们随机的初始化，但是如果这些对象之间有要求有顺序，怎么办？你乱序初始化可能会出错的。这时候我们可以使用单例模式来保证正确的顺序。
```cpp
#include <iostream>
using namespace std;

class my_class {
 public:
  my_class& singleton() {
    static my_class mls;
    return mls;
  }
};
// extern my_class mls;
```

# 结语
 不要乱写类的构造函数，少写非局部静态变量。